---
title: "02.1_Descr_Analysis_Microbiote"
author: "Dupret Florent"
date: "`r Sys.Date()`"
output:
  html_document: 
    df_print: kable
    theme: yeti
    highlight: tango
    toc: yes
    toc_depth: 4
    toc_float: yes
    number_sections: yes
    fig_caption: yes
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.show='hold', cache = FALSE, results = 'hold', error = FALSE, warning = FALSE, message = FALSE)
#Cleaning rstudio
rm(list = ls())
#Libraries required
require(ggplot2)
require(tidyverse)
require(FactoMineR)
require(visdat)
require(readr)
require(patchwork)
require(limma)
require(SummarizedExperiment)
require(MultiAssayExperiment)
require(pander)
require(bookdown)

library(phyloseq)
require(alto) # devtools::install_github("lasy/alto")
require(ValenciaR) #devtools::install_github("lasy/ValenciaR")
```

```{r, include=FALSE}
#Importing personal functions
fs::dir_map(path = "../04_Analyses/Desc_functions",
            fun = source)
#Ggplot theme
theme_set(theme_minimal())
#Colors for Cohort and Batch
CohCol <- c("#F8766D", "#00BFC4") #Ggplot default binary colors
names(CohCol) = c("Stanford", "UMD")
BatchColors = c("firebrick", "#FEB7AA")
names(BatchColors) = c("Batch1", "Batch2")
```

Understanding what's inside a dataset and how one could transform it to obtain a clean and practical object is one of the first steps of analyzing data. In this section, we focus on the descriptive analysis and pre-processing of the microbiota dataset.

Let us import the main MultiAssayExperiment object and work our way through all the important aspects of its content.

```{r}
#Import
STAN <- readRDS("../05_Results/STANFORD_mae.Rds")
UMD <- readRDS("../05_Results/UMD_mae.Rds")
```

First of all, one must consider the type of data and how it was acquired. In this case, the data corresponds to RNA sequencing count data of 16S rRNA. There were `r ncol(STAN[["VM"]])` samples in Stanford, `r ncol(UMD[["VM"]])` samples in UMD, and admittedly `r nrow(STAN[["VM"]])` sequences in for both Stanford and UMD RNAseq.

## Row metadata descriptive analysis

The row metadata associated with the microbiota set is composed of `r ncol(rowData(STAN[["VM"]]))` columns:

* `ASV`: a portion of the species-specific 16S rRNA Amplicon Sequence Variant

* `ASV_assay_key`: the database key for identifying the species

* `ASV_usename`: a shorter name for the assay key

* `total_counts`: ASV total count (the sum of all counts across samples)

* `Lowest_Level_Available`: Lowest taxonomic level available for the identified sequence

* `Lowest_Level_Info`: Lowest taxonomic name (corresponding to the lowest taxonomic level) according to the database

* `Kingdom`, `Phylum`, `Class`, `Order`, `Family`, `Genus`, `Species`: information regarding the phylogeny of the identified species. Takes a blanc value `""` if unknown.

* `Species_full`: sub-species identification according to the database; takes the value `NA` if inexistent or unknown.

* `strain_nb`: number of species from the same strain. For example, if we had identified 3 `Lactobacillus spp.` then all of them would have a strain_nb of "3".

Here are the distribution of recorded bacterias according to `Kingdom` and `Phylum`

```{r}
# Counts of different phylum categories (just for insight)
rowData(UMD[["VM"]]) |> xtabs(formula = ~ Phylum + Kingdom) |>
  pander()
```


## Total library size {.tabset .tabset-pills}

*Visualizing total library size*

When dealing with count data, the number of read sequences $r$ using RNAseq is arbitrary and does not necessarily represent the true number of sequences $n$ in the sample. Indeed, the sample contains $n=n_1 + n_2 + ... + n_I$ sequences from the $i=1,2,...,I$ genes. The probability of reading gene $i$ can be estimated by $\frac{n_i}{n}$. However, as samples can be vary different from one patient to another or from one day to another, in terms of quality and bacterial concentration, this probablity varies grealty and therefore the total number of reads $r$ can fluctuate greatly.

This total number of reads $r$ is sometimes called _sequencing depth_ or _library size_ and has been recorded in our given data by the name `SampleSum`.

It is frequent in statistical data analyses of count data to study this library size and to transform the data prior to main analyses so as to make the samples comparable. In the case of investigating sample composition, the best way to handle the library size and corresponding data is to use relative abundances. This transformation is part of the next section \@ref(Rel.Abund)

Here is the library size of Stanford and UMD RNAseq data:

```{r, out.width='50%', warning = TRUE}
#Library size comparison
##STANFORD
tibble(SampleSum = colData(STAN[["VM"]])$SampleSum,
       Batch = colData(STAN[["VM"]])$Batch) |>
  arrange(SampleSum) |>
  ggplot()+
  aes(x = 1:ncol(STAN[["VM"]]), y = SampleSum, fill = Batch)+
  geom_col(position = "identity", width = 1) +
  scale_fill_manual(values = BatchColors)+
  theme(axis.text.x = element_blank(), legend.position = "bottom")+
  labs(x = "Sample", y = "Library size",
       fill = "Batch", title = "Stanford samples")
##UMD
tibble(SampleSum = colData(UMD[["VM"]])$SampleSum,
       Batch = colData(UMD[["VM"]])$Batch) |>
  arrange(SampleSum) |>
  ggplot()+
  aes(x = 1:ncol(UMD[["VM"]]), y = SampleSum)+
  geom_col(position = "identity", width = 1, fill = CohCol["UMD"]) +
  theme(axis.text.x = element_blank(), legend.position = "bottom")+
  labs(x = "Sample", y = "Library size", title = "UMD samples")
```

While generating these plots, R sent an error message informing us on 7 columns for which the library size was missing (`NA`). Indeed, there are `r sum(is.na(STAN[["VM"]]$SampleSum))` missing library size in Stanford and `r sum(is.na(UMD[["VM"]]$SampleSum))` in UMD. These missing library sizes (and missing columns) come from the data preparation section and were created artificially to match the number of samples. Of course, no information can be considered from these 7 samples, in terms of microbial composition.


## Relative abundances

As mentioned before, relative abundance is the best way to understand count data for analysing microbial composition. One could also suggest to normalize count data. However, in this case, we cannot make the assumption of parsimonious gene expression. Microbial composition data is a bit more complicated than that. Instead, one has to realize that we are studying the presence of bacterias in different women's vaginal environment. Moreover, experience has shown us that women usually have very diverse microbiotas [source](). Therefore, one must not consider the gene expression to be biologically similar in every sample and must not rely on normalization techniques.

Instead, the ratio between the microbe specific count and the total sample count will be used. In terms of notations, let $X_{ij}$ be the count for the $i$^th^ gene of the $j$^th^ sample and let $R_j=\sum_{i=1}^n X_{ij}$ quantify the library size of the $j$^th^ sample. Then the new relative abundance table $X^{rel}$ is given by:

$$
X^{rel} = [X^{rel}_{ij}]_{i=1,...,n;j=1,...,p} =\bigg[ \frac{X_{ij}}{R_j} \bigg]_{i=1,...,n;j=1,...,p}
$$

Relative abundance has the advantage of simplifying interpretations. For example, noting that the proportion of _Lactobacillus crispatus_ is greater in women with higher tyramine concentration, compared to women with lower tyramine concentration, might be helpful for associating metabolites and microbiota composition. Indeed, this is the objective of the main study: to identify and understand the correlations and associations between metabolic profile and microbial composition.

```{r}
rel.stan <- scale(assay(STAN[["VM"]]), center = FALSE, 
                  scale = colSums(assay(STAN[["VM"]]), na.rm = TRUE))
rel.umd <- scale(assay(UMD[["VM"]]), center = FALSE, 
                 scale = colSums(assay(UMD[["VM"]]), na.rm = TRUE))
```

Here are visualizations of Stanford and UMD sample microbial composition using relative abundance data:

```{r}
bar_plot <- function(matrix, n, cohort = c("Stanford", "UMD"), sp = "Lactobacillus crispatus"){
  #Extracting count data
  counts <- data.frame(matrix, check.names = F)
  #Aggregating by ASV usename
  agg_long <- 
    counts |>
    mutate(name = gsub("\\[.*?\\] ", "", rownames(counts))) |> 
    pivot_longer(cols = 1:ncol(counts), 
                 names_to = "Sample", values_to = "Count") |>
    group_by(name, Sample) |>
    summarise(Agg_count = sum(Count))
  #Selecting species name with n highest counts
  top_species <- 
    agg_long |>
    group_by(name) |>
    summarize(total = sum(Agg_count)) |>
    ungroup() |>
    arrange(desc(total)) |>
    slice_head(n = n) |>
    pull(name)
  #Labelling n most abundant species
  abund_long <- agg_long |>
    mutate(label = if_else(name %in% top_species, as.character(name), "Other"))
  
  if(is.character(sp)){
  # Arrange sample by descreasing prop of species of interest
  ordered_abund_long <- abund_long |>
    filter(name == sp) |>
    arrange(desc(Agg_count)) |>
    select(Sample)
  
  data <- abund_long |>
    mutate(Sample = factor(Sample, levels = ordered_abund_long$Sample)) |>
    arrange(Sample)
  } else {data <- abund_long}
  # Plotting
  data |>
    ggplot()+
    aes(x = Sample, y = Agg_count, 
        fill = label)+ 
    geom_bar(stat="identity", position="stack", width = 1)+
    scale_y_continuous(labels = scales::label_percent())+
    labs(y = "Relative abundance", fill = "Species",
         title = paste0(cohort, " compositional barplot"))+
    theme(axis.text.x = element_blank())
}
```
```{r, out.width='50%'}
bar_plot(matrix = rel.stan, n = 10, cohort = "Stanford", sp = "Lactobacillus crispatus")
bar_plot(matrix = rel.umd, n =13, cohort = "UMD", sp = "Lactobacillus crispatus")
```


```{r}
#Saving Relative abundance table
STAN <- 
  c(STAN, VM_abund = SummarizedExperiment(assays = rel.stan,
                              rowData = rowData(STAN[["VM"]])))

UMD <- 
  c(UMD, VM_abund = SummarizedExperiment(assays = rel.umd,
                              rowData = rowData(UMD[["VM"]])))
```


## Lactobacillus proportions

Bacterial genus _Lactobacillus_ is quite important in this project as it is key to healthy vaginal microbiota. Lactobacillus dominated vaginal microbiota usually prevent diseases, infections and other unwanted circumstances. Moreover, researchers have a lead on the transition from healthy Lactobacillus dominated vaginal microbiota to vaginal dysbiosis and cmplications. Bacteria of the Lactobacillus genus play a major role in keeping the microbiota stable and preventing nasty bacterial species from taking the upper hand.

Broadly speaking, the popular understanding of the mecanism through which Lactobacillus monopolize the microbiota and "keep it in check" is by producing lactic acid (or `lactate`). This acid raises the pH in the environment, thus making it unbearable for most non-Lactobicallus bacterial species. High pH prevents many bacterias from functioning correctly and multiplying. Consequently, one can expect a great positive correlation between lactate concentration and _Lactobacillus spp._ presence, and a negative correlation between lactate and non-Lactobacillus species.

```{r ComputePropBact, echo = F}
ComputePropBact <- function(source, pattern = "Lactobacillus"){
  if(class(source)[1] == "MultiAssayExperiment"){
    VM <- source[["VM"]]
    PatternSum <- colSums(assay(VM)[str_detect(rownames(VM), pattern = pattern), ])
    SampleSum <- VM$SampleSum
    Prop <- PatternSum / SampleSum
  } else if(class(source)[1] == "data.frame"){
    VM <- source
    PatternSum <- colSums(VM[str_detect(rownames(VM), pattern = pattern), ])
    SampleSum <- colSums(source)
    Prop <- PatternSum / SampleSum
  } else if(class(source)[1] == "matrix"){
    VM <- source
    PatternSum <- colSums(VM[str_detect(rownames(VM), pattern = pattern), ])
    SampleSum <- colSums(source)
    Prop <- PatternSum / SampleSum
  } else{Prop = paste("This function only allows MultiAssayExperiment, data.frame and matrix objects")}
  
  return(Prop)
}
```
```{r, out.width='50%'}
tibble(Set = "Stanford",
       PropLacto = ComputePropBact(rel.stan)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["Stanford"], width = 1)+
  labs(y = "Lactobacillus spp. proportion", x = "Samples",
       title = "Stanford")+
  theme(axis.text.x = element_blank())
tibble(Set = "UMD",
       PropLacto = ComputePropBact(rel.stan)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["UMD"], width = 1)+
  labs(y = "Lactobacillus spp. proportion", x = "Samples",
       title = "UMD")+
  theme(axis.text.x = element_blank())
```

One could also go into detail and look for the proportion of _Lactobacillus iners_ or _Gardnerella vaginalis_:

```{r, out.width='50%'}
##Lactobacillus iners
pattern <- "Lactobacillus iners"
tibble(Set = "Stanford",
       PropLacto = ComputePropBact(rel.stan, pattern = pattern)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["Stanford"], width = 1)+
  labs(y = paste(pattern,"proportion"), x = "Samples",
       title = "Stanford")+
  theme(axis.text.x = element_blank())
tibble(Set = "UMD",
       PropLacto = ComputePropBact(rel.umd, pattern)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["UMD"], width = 1)+
  labs(y = paste(pattern,"proportion"), x = "Samples",
       title = "UMD")+
  theme(axis.text.x = element_blank())
##Gardnerekka vaginalis
pattern <- "Gardnerella vaginalis"
tibble(Set = "Stanford",
       PropLacto = ComputePropBact(rel.stan, pattern = pattern)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["Stanford"], width = 1)+
  labs(y = paste(pattern,"proportion"), x = "Samples",
       title = "Stanford")+
  theme(axis.text.x = element_blank())
tibble(Set = "UMD",
       PropLacto = ComputePropBact(rel.umd, pattern)) |>
  arrange(PropLacto) |>
  ggplot()+
  aes(y = PropLacto, x = 1:length(PropLacto))+
  geom_col(fill = CohCol["UMD"], width = 1)+
  labs(y = paste(pattern,"proportion"), x = "Samples",
       title = "UMD")+
  theme(axis.text.x = element_blank())
```


## Topics models

```{r}
rm(rel.stan, rel.umd, pattern)
```

Diagnosis is an example of classification: a patient is either diagnosed with a pathology or is healthy. With women vaginal health, researchers have developped a classification system based on the proportions of microbial species one can find in a sample. If there are $k$ categories in this classification system, the $k^{\text{th}}$ class is defined by the proportions $p_{jk}$ of species $j = 1,...,J$. For example, \emph{class I} corresponds to microbiomes dominated by \textit{Lactobacillus crispatus}. \emph{Class IV} corresponds to microbiota not dominated by \textit{Lactobacillus spp.} but composed of a wide variety of bacterial species.
[source1](Kaambo, E., Africa, C., Chambuso, R., & Passmore, J. S. (2018). Vaginal Microbiomes Associated With Aerobic Vaginitis and Bacterial Vaginosis. Frontiers in public health, 6, 78. https://doi.org/10.3389/fpubh.2018.00078) [source2](Ravel, J., Gajer, P., Abdo, Z., Schneider, G. M., Koenig, S. S., McCulle, S. L., Karlebach, S., Gorle, R., Russell, J., Tacket, C. O., Brotman, R. M., Davis, C. C., Ault, K., Peralta, L., & Forney, L. J. (2011). Vaginal microbiome of reproductive-age women. Proceedings of the National Academy of Sciences of the United States of America, 108 Suppl 1(Suppl 1), 4680â€“4687. https://doi.org/10.1073/pnas.1002611107) [source3](De Seta, F., Campisciano, G., Zanotta, N., Ricci, G., & Comar, M. (2019). The Vaginal Community State Types Microbiome-Immune Network as Key Factor for Bacterial Vaginosis and Aerobic Vaginitis. Frontiers in microbiology, 10, 2451. https://doi.org/10.3389/fmicb.2019.02451). In the case of bacterial vaginosis, these classes are called community state types (CST). Additionally, there are variants of the five main classes (CST I through V) called sub-community state types (subCST) which take the name "CST I-A", "CST III-B", etc. 

This classification can express the transition from a healthy microbiome (CST I) to microbiome prone for bacterial vaginosis (CST IV). Although it is better than a binary system (e.g. either healthy or BV), it is not optimal. Probably, women's vaginal microbiota cannot be defined and classified into a fixed number $k$ of classes.

Instead, one relatively novel idea was to express the microbiote composition in terms of proportion of these \emph{topics}, which is a more general name encompassing the CSTs and subCSTs. Maybe, a given sample is not 100% CST I, but rather 90% CST I-A, 7% CST I-B, and 3% CST IV-C. This type of system is called a \emph{mixed membership model}: samples are allowed to be a mixture of multiple subcommunities. THIS is an example of soft-classification.

One has to concieve that such model is not optimal and does not reflect entirely the true biological composition of a women's vagina. However, it is better at expressing the transition from one state to another. One disadvantage of this model is that it still requires to characterize the different communities present in the whole population. If this population is vague and ill-defined, then there is a risk of erroneously representing the samples' topics.

With UMD and Stanford, there might be such a risk. All participants lived in the United States, the age range (`r range(STAN[["MB"]]$Age)`) did not cover the bigger population, etc. The topics could then be inaccurate and not generalizable.

The whole of the topics model analysis was done using the `alto` package, which is a wrapper around the `lda` package, and which allows to examine how subcommunities relate to each other across models with different number of subcommunities.

Furthermore, for this exceptional analysis, the UMD and Stanford data were combined because re-categorizing the bacterial species into topics is supposed to be the same regardless of the population. However, one might bring forth the argument that UMD and Stanford samples were not prepared the exact same way and may lead to biases. Indeed, such bias is most probably occuring. Nonetheless, the reliability of metagenomics data is actually dependent on many factors and controlling for all of them is not reasonable. On the contrary, stating that species can be grouped into communities and these communities appear in different proportions accross individuals is quite rational. It is because we are working with proportions of communities that we can omit the hypothesis of university effect, in this particular case.

### CST and sub-CST assignment

Let us compare the number of samples to fall in each category of the pre-defined CST categorisation system:

```{r}
#Extracting SE
VM.stan <- STAN[["VM"]]
VM.umd <- UMD[["VM"]]
#Extracting the raw count table
counts.stan <- assay(VM.stan) |> t()
counts.umd <- assay(VM.umd) |> t()
#Verifying column order
#sum(colnames(counts.stan) == colnames(counts.umd)) #must be equal to 3950
#Combining UMD and STAN count data
counts <- rbind(counts.stan, counts.umd)

#Formatting count data as "otu physeq object"
ASV <- otu_table(object = counts, taxa_are_rows = FALSE)

#Selecting the taxonomy table from the rowdata
tax <- rowData(VM.stan) %>% 
  as.data.frame() %>% 
  mutate(Domain = Kingdom) %>%
  dplyr::select(ASV_usename, Domain, Phylum, Class, Order, Family, Genus, Species) |>
  as.matrix() |>
  tax_table()

#Creating sample metadata table
sam_data <- 
  rbind(colData(VM.stan),
        colData(VM.umd)) |>
  data.frame() |>
  sample_data()

#Creating physeq object with
physeq <- phyloseq(ASV, tax, sam_data)
rank_names(physeq)
```

```{r}
#Agglomerating at the species level
physeq_agg <- phyloseq::tax_glom(physeq, taxrank = "Species")

colnames(physeq_agg@otu_table@.Data) <- 
  gsub("\\[.*?\\] ", "", colnames(physeq_agg@otu_table@.Data))
rownames(physeq_agg@tax_table@.Data) <- 
  gsub("\\[.*?\\] ", "", rownames(physeq_agg@tax_table@.Data))
#Defining count data
counts <- physeq_agg@otu_table@.Data
```

```{r}
#Creating an object with the count table and its corresponding taxonomy table for each species
counts_Valencia <- 
  ValenciaR::convert_to_Valencia_taxonomy(
    input = physeq_agg@otu_table@.Data,
    tax_table = as.data.frame(physeq_agg@tax_table@.Data)
  )

assignments <- 
  ValenciaR::assign_to_Valencia_clusters(
    input = counts_Valencia$converted_input,
    distance = "YC"
  )

CST_assay <- list()
CST_assay[["CST"]] <- 
  SummarizedExperiment::SummarizedExperiment(
    assay = assignments$assignment |> t()
  )
#STAN <- c(STAN, CST_assay)
```

```{r}
assignments$assignment |> 
  ggplot(aes(y = subCST |> fct_rev())) +
  geom_bar() +
  facet_grid(CST ~ ., scales = "free", space = "free") +
  ylab("CST/subCST") + xlab("Number of samples associated with a given subCST")+
  theme(strip.text.y = element_text(angle = 0))
```

```{r}
assignments$assignment |> 
  ggplot(aes(x = distance_to_subCST)) +
  geom_histogram(binwidth = 0.02) +
  facet_grid(subCST ~ ., scales = "free") +
  theme(strip.text.y = element_text(angle = 0)) +
  ylab("Number of samples")+
  xlab("Dissimilarity to subCST centroid (Bray-Curtis distance)")
```

From the previous graphs, there is a higher number of samples in subCST I-A, III-A, and IV-B: the first two are \textit{Lactobacillus}-dominated, while the third one is non-\textit{Lactobactillus}-dominated (i.e. all subCSTs in CST IV). There is also very few samples in IV-C1, IV-C3, and IV-C4.

Now remember that this previous representation corresponds to fixed allocation clustering: a sample is either in one or the other cluster.

### Topics models

```{r}
#Max number of subcommunities
max_K <- 20
```

Let us fit a topic model for Stanford samples. In the first step of this fitting process, there is only one group (i.e. $k = 1$). Therefore, all samples will belong in this group. At this stage, the group can be considered as a cluster with individuals ($i=1,...,n$ samples) at a certain distance $d_i^{(1)}$ from the cluster's center. In the next step, we increase the number of clusters to $k=2$ and re-compute the distance $d_i^{(2)}$ between the cluster's centers and the individuals. The individuals are then labeled based on this new distance: individuals belong to their closest center. This process repeats for any number of clusters $k$. In our case, we decided to reach a maximum of `r max_K` clusters.

In addition to assigning individuals (samples) to their cluster, we also need to characterize the clusters based on the bacterial composition (it will then be called a "topic"). Ideally, the topics should match the existing predefined CST and subCST we mentionned earlier. However, it is only when $k=12$ that the matching is supposed to be perfect (because we identified 12 different subCST). We note that matching might not be perfect because the CST were defined from other sources of compositional data. The newly defined topics (which represent sub-communities of bacteria) must be labelled based on their most similar subCST's. [MAE_augmentation](file:///C:/Users/dupre/OneDrive%20-%20UCL/Florent_masters_project/99%20Resources/lactinv_code/02_mae_augmentation/mae_augm_script/main_script_20240314.html).

At one point during the iterative process, it might be that the number of topics $k$ is too great and that two (or more) 'different' topics share very similar subCST composition. When such an event happens, we can conclude the optimal number of topics is below that $k$. The previous scenario expresses the need to distinguish between the \emph{path} -- the number of different sub-communities, which have biological meaning -- and the number of clusters $k$ -- the fixed number of different centers in mathematical sub-space --. The choice of the number of topics may also rely on metrics like \emph{coherence score} and \emph{refinement score}. More about these scores can be found in \cite{Symuletal}. The choice of the optimal number of topics $K$ is based on maximizing the coherence score and finding the passage from an increasing curve to a plateau in the refinement-vs-number of topics plot.

One can draw the partitionning of samples as the number of topics increases: this called the alignment between the paths and topics. Such graph can be based on the similarities of sub-community composition -- the \emph{transport alignment} -- or based on the similarities of sample composition -- the \emph{product alignment} --.

Let us draw both of these graphs:

```{r}
#lda topic model
lda_models <- 
  run_lda_models(data = counts,
                 lda_varying_params_lists = setNames(purrr::map(1:max_K, ~ list(k = .)), 1:max_K),
                 dir = "lda_models/lda_models_StanAndUmd",
                 reset = FALSE,
                 verbose = TRUE)

#Formatting to Valencia clusters
valencia_centroids_mat <- ValenciaR::get_Valencia_clusters()

#Labeling new subcommunities based on their microbial composition
labelled_lda_models <- 
  label_models_topics(
    lda_models = lda_models,
    tax_table = data.frame(physeq_agg@tax_table@.Data, check.names = F),
    valencia_centroids_mat = valencia_centroids_mat,
    distance = "YC"
  )

#SummarizedExperiment::rowData(STAN[["VM"]]) |> as.data.frame() %>% mutate(Domain = Kingdom)

rm(assignments, counts_Valencia, CST_assay, sam_data, valencia_centroids_mat, ASV, tax, lda_models, VM.stan)
```
```{r}
#Transport alignment plot
aligned_topics_transport <- 
  align_topics(models = labelled_lda_models, method = "transport")

plot(aligned_topics_transport) +
  labs(title = '"Transport" alignment',
       subtitle = "(= based on the similarities of sub-community compositions)",
       xlab = "Number of sub-communities (topics)")

#Product alignment plot
aligned_topics_product <- 
  align_topics(models = labelled_lda_models, method = "product")

plot(aligned_topics_product) +
  labs(title = '"Product" alignment',
       subtitle = "(= based on the similarities of sample compositions)",
       xlab = "Number of sub-communities (topics)")
```

The transport alignment shows 3 consistent paths colored in light blue, bright pink, red. These paths are probably very distinctive bacterial communities. The product alignment shows 2 or more recurrent paths: orange, red, etc.

Let us see the number of paths vs the number of topics

```{r}
topics <- 
  bind_rows(
    aligned_topics_transport@topics |> mutate(method = "transport"),
    aligned_topics_product@topics |> mutate(method = "product")
  )

plot_number_of_paths(compute_number_of_paths(aligned_topics_transport)) +
  ggtitle("Transport") +
plot_number_of_paths(compute_number_of_paths(aligned_topics_product)) +
  ggtitle("Product")
```

The transport and product graph are not necessarily in agreement toward the first plateau (13 in transport and 9 in product). However, both see a plateau after 13 topics. In that case, we can expect a maximum number of topics around this value of 13.

Let us also look at two scores for each model.

```{r}
ggplot(topics, aes(x = m, y = coherence, fill = method, col = method)) +
  geom_boxplot(alpha = 0.5) + labs(x = "K") +
ggplot(topics, aes(x = m, y = refinement, fill = method, col = method)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_boxplot(alpha = 0.5) + labs(x = "K")+
  plot_layout(guides = "collect")
```

The coherence score graph does not reveal a model with an outstanding score. Nonetheless, the scores in model 7 or 8 might be the highest. The plateau in refinement score is relatively visible at 11 topics in the product alignment and at 16 topics in the transport alignment. From the collection of these conclusions, it is hard to decide which number $K$ is the best.

The final plot we can explore is the "beta plot". The beta plot is a plot of the proportion of species in each topic. It contrasts with the "gamma plot" which shows the proportion of samples in each topic. Let us summarize the information of the beta plot into the matrix $\beta$ of dimension $k \times p$ (where $k$ is the number of topics and $p$ is the number of species), and summarize the information of the gamma plot into the matrix $\gamma$ of dimension $n \times k$ (where $n$ is the number of samples). One can actually express the count data table $X$ (dimension $n \times p$) as a function of the $\gamma$ and $\beta$ such that: $X \sim \gamma \times \beta$.

```{r}
plot_beta(aligned_topics_transport, models = c(9,11))
plot_beta(aligned_topics_transport, models = c(13))
```

The beta plot shows very distinct communities when considering 11 or 13 topics. Moreover, all models agree on the first 3 topics, namely the ones with a majority of \textit{Lactobacillus iners, crispatus} and \textit{gasseri}. There is also a distinctive topic with a majority of \textit{Lactobacillus jensenii} showing. The rest of the topics are dominated by non-lactobacilli.

Because the model with 13 topics seems to be robust (taking into account the results of the beta plot, the metrics, the transport and product alignment), we determine the optimal number of topics to be $K=13$

```{r}
optimal_K <- 13
#Extracting the beta matrix for k=10 topics
topic_SE <- 
  make_topic_SE(
    assay_name = str_c("VM_topics_", optimal_K), 
    lda_model = labelled_lda_models[[optimal_K]]
  )
#Saving beta matrix in MAE
#STAN <- c(STAN, topic_SE)
MAE <- MultiAssayExperiment(
  experiments = topic_SE
)
```

### "Constrained" topic models of the taxa counts

From experience, researchers have established that some vaginal microbiota are dominated by \textit{Lactobacillus spp.} while others are dominated by non-\textit{Lactobacillus} species. Therefore, there are strong evidence in favor of a dichotomisation of the types of microbial communities according lactobacilli microbial domination. Moreover, in the topic model philosophy, there are sometimes issues with the weight of the topics in a sample because the sample is characterized in terms of proportions of sub-communities. When using proportions, samples with low counts can stand out from the group because of technical issues rather than biological signals.

These observations led to speculating that some topics could be given weights according to their content. Such weighting procedure is taken into account by \emph{constrained topic models}. With this model, we will first define the \textit{Lactobacillus}-dominated topics and then the non-\textit{Lactobacillus}-dominated topics.

```{r}
beta_long <- get_beta_long(MAE, assayname = str_c("VM_topics_", optimal_K))
beta_long |> 
  filter(topic %in% c("I", "II", "III","V")) |> 
  filter(prop > 1/500) |>
  arrange(topic, -prop) |>
  mutate(taxa = taxa |> factor(levels = unique(taxa))) |> 
  ggplot(aes(y = taxa |> fct_rev(), x = prop, fill = topic)) +
  geom_bar(stat = "identity") +
  facet_grid(. ~ topic) +
  guides(fill = "none") +
  ylab("") + xlab("proportion in topic") +
  scale_fill_viridis_d(option = "A", direction = -1, end = 0.85, begin = 0.2
    )+
  theme(axis.text.x = element_text(angle = -90))
```

#### Lactobacillus topics

Let us compare the proportion of the most abundance bacterial species of \textit{Lactobacillus} in the samples:

```{r}
#Recomputing the relative abundance table from agglomerated count table
temp <- data.frame(physeq_agg@otu_table@.Data, check.names = F) |> t()
props <- scale(temp, center = FALSE, scale = colSums(temp))
#Saving the new relative abundance table
SE <- SummarizedExperiment(assays = props, 
                           rowData = physeq_agg@tax_table@.Data,
                           colData = rbind(colData(STAN[["VM"]]),
                                           colData(UMD[["VM"]])))

MAE <- c(MAE, VM_abund_agg = SE)

#Switching to long format for props table
props_long <- 
  get_assay_long_format(
    MAE, "VM_abund_agg", add_colData = FALSE,
    feature_name = "taxa", values_name = "prop")
```
```{r}
#Plotting the proportion of species in samples
props_long_lacto <- 
  props_long |>  
  filter(str_detect(taxa, "Lactobacillus")) |> 
  group_by(taxa) |>
  mutate(median_prop = median(prop)) |> 
  ungroup() |> 
  arrange(-median_prop) |>
  mutate(
    taxa = taxa |> str_replace(" ","\n"),
    taxa = taxa |> factor(levels = unique(taxa)))
props_long_lacto |> 
  ggplot(aes(y = taxa |> fct_rev(), x = prop, col = taxa)) +
  geom_jitter(width = 0, height = 0.15, size  = 0.5) +
  xlab("Proportion in samples") + ylab("") +
  theme(axis.text.y= element_text(size = 7))+
  guides(col = "none")
```

As we can see, the top 4 species are the ones with the highest median proportion and correspond to \textit{Lactobacillus iners, crispatus, jensenii}, and \textit{gasseri}. It makes sense to consider these 4 species are 

```{r}
Lacto_topics_beta <- 
  matrix(0, nrow = nrow(props), ncol = 5) |> 
  set_colnames(c("I", "II", "III","V","VI")) |> 
  set_rownames(rownames(props))

Lacto_topics_beta[str_detect(rownames(Lacto_topics_beta), "Lactobacillus crispatus"),"I"] <- 1
Lacto_topics_beta[str_detect(rownames(Lacto_topics_beta), "Lactobacillus gasseri"),"II"] <- 1
Lacto_topics_beta[str_detect(rownames(Lacto_topics_beta),"Lactobacillus iners"),"III"] <- 1
Lacto_topics_beta[str_detect(rownames(Lacto_topics_beta),"Lactobacillus jensenii"),"V"] <- 1

all_Lacto_species <- str_subset(rownames(props), "Lactobacillus")
#other_Lacto_species <- setdiff(all_Lacto_species, str_c("Lactobacillus ", c("crispatus","iners","jensenii")) )

other_Lacto_species <- all_Lacto_species[!str_detect(all_Lacto_species, "Lactobacillus jensenii")]
other_Lacto_species <- other_Lacto_species[!str_detect(other_Lacto_species, "Lactobacillus iners")]
other_Lacto_species <- other_Lacto_species[!str_detect(other_Lacto_species, "Lactobacillus crispatus")]
other_Lacto_species <- other_Lacto_species[!str_detect(other_Lacto_species, "Lactobacillus gasseri")]

t.props <- t(props)
Lacto_topics_beta[other_Lacto_species,"VI"] <- 
  colSums(t.props[,other_Lacto_species])/sum(t.props[,other_Lacto_species])
```
```{r}
Lacto_topics_beta |> 
  as.data.frame() |> 
  rownames_to_column("Taxa") |>
  pivot_longer(-Taxa, names_to = "topic", values_to = "prop") |>
  filter(prop > 0) |>
  arrange(topic, -prop) |>
  mutate(Taxa = Taxa |> factor(levels = unique(Taxa))) |> 
  ggplot(aes(y = Taxa |> fct_rev(), x = topic)) +
  geom_tile(aes(alpha = prop), fill = "#F56172") +
  geom_text(aes(label = round(prop,2)), size = 4) +
  ylab("") + xlab("Topic")+
  labs(subtitle = "Species weights per topic")
```

```{r}
Lacto_topics_gamma <- 
  cbind(
    t.props[, str_detect(colnames(t.props), "Lactobacillus crispatus")],
    t.props[, str_detect(colnames(t.props), "Lactobacillus gasseri")],
    t.props[, str_detect(colnames(t.props), "Lactobacillus iners")],
    t.props[, str_detect(colnames(t.props), "Lactobacillus jensenii")],
    rowSums(t.props[, other_Lacto_species])
  ) |> 
  set_colnames(c("I", "II", "III","V","VI"))
```
```{r}
Lacto_topics_gamma |> 
  as.data.frame() |> 
  rownames_to_column("sample") |>
  pivot_longer(-sample, names_to = "topic", values_to = "prop") |>
  ggplot(aes(x = prop)) +
  geom_histogram(bins = 50) +
  facet_grid(topic ~ ., labeller = label_both) +
  scale_x_continuous(labels = scales::label_percent())+
  theme(strip.text.y = element_text(angle = 0))+
  labs(title = "Number of samples of a given proportion for each topic",
       x = "Sample proportion for given topic")
```

The graph is better understood with a intepretation example: in the first row ('topic I'), we can say there is approximately 270 samples, out of `r nrow(counts)`, which correspond to 0% of topic I. In that same row, there is approximately 20 samples with 100% of topic I. The same interpretation pattern can be done for all rows (all topics).

From the previous graph, we need to detect any inconsistency or outlier. A example of inconsistency is if one of the rows had many samples in high proportion of one topic. From the previous graph, we cannot see any inconsistency.

#### Non-lactobacillus topics

Similarly to the first section where we needed to find an efficient number of topics, we must do the same with the non-lactobacillus topics. Once again, the models are computed iteratively with each iteration augmenting the number of topics. We will then compare the models using different plots and graphical visualizations.

```{r}
# we remove the Lacto species
non_Lacto_counts <- counts[, !(colnames(counts) %in% all_Lacto_species)]
# we remove the samples that only have Lacto species
non_Lacto_counts <- non_Lacto_counts[rowSums(non_Lacto_counts) != 0, ]

max_K <- 20

lda_models <- 
  run_lda_models(
    data = non_Lacto_counts, 
    lda_varying_params_lists = 
      setNames(purrr::map(1:max_K, ~ list(k = .)), 1:max_K),
    dir = "lda_models/lda_model_StanAndUmd_nonLacto",
    reset = FALSE, 
    verbose = TRUE
  )

tax_table <- 
  SummarizedExperiment::rowData(MAE[["VM_abund_agg"]]) |> 
  as.data.frame()
tax_table <- tax_table[colnames(non_Lacto_counts), ] ##|> mutate(Domain = Kingdom)

#Labelling topics based on similarity with existing subCST
labelled_lda_models <- 
  label_models_topics(
    lda_models = lda_models,
    tax_table = tax_table,
    valencia_centroids_mat = ValenciaR::get_Valencia_clusters(),
    distance = "YC"
  )
```
```{r}
#Transport alignment plot
aligned_topics_transport <- 
  align_topics(models = labelled_lda_models, method = "transport")

plot(aligned_topics_transport) +
  labs(title = '"Transport" alignment',
       subtitle = "(= based on the similarities of sub-community compositions)",
       xlab = "Number of sub-communities (topics)")

#Product alignment plot
aligned_topics_product <- 
  align_topics(models = labelled_lda_models, method = "product")

plot(aligned_topics_product) +
  labs(title = '"Product" alignment',
       subtitle = "(= based on the similarities of sample compositions)",
       xlab = "Number of sub-communities (topics)")
```

From the transport alignment plots, the green, bright pink and light blue paths are the most consistent. In the product alignment plot, the distinction is less obvious but the pink and orange paths are consistent up to model 7-8. In that case, it might be better to choose a reasonable amount of topics with fewer than 8 different topics.

```{r}
topics <- 
  bind_rows(
    aligned_topics_transport@topics |> mutate(method = "transport"),
    aligned_topics_product@topics |> mutate(method = "product")
  )

plot_number_of_paths(compute_number_of_paths(aligned_topics_transport)) +
  ggtitle("Transport") + xlab("K") +
plot_number_of_paths(compute_number_of_paths(aligned_topics_product)) +
  ggtitle("Product") + xlab("K")
```

After 5 topics, there is a plateau in the product alignment. There is a second plateau at 8 topics. Then, both alignment reveal a decreasing curve at 14 topics. Therefore, it makes sense to choose a number of non-\textit{Lactobacillus} topics below or equal to 8.

```{r}
ggplot(topics, aes(x = m, y = coherence, fill = method, col = method)) +
  geom_boxplot(alpha = 0.5) + xlab("K") +
ggplot(topics, aes(x = m, y = refinement, fill = method, col = method)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_boxplot(alpha = 0.5) + xlab("K") +
  plot_layout(guides = "collect")
```

Finally, at 5 topics, the coherence score is already high (and higher than 8 topics) and the refinement score is already far from the diagonal.

```{r}
plot_beta(aligned_topics_transport, models = c(5,8))+
  theme(axis.text.y = element_text(size = 8),
        axis.text.x = element_text(angle = -90))
```

Through the beta plots and the rest of the results, $5$ topics might be a good compromise between dimension reduction and information gain.

### Combining with \emph{Lactobacillus} and non-\emph{Lactobacillus} topics

Finally, we have $K=5+5=10$ topics which we can visualize through a beta plot:

```{r}
combined_topics <- 
  combine_topics(5, labelled_lda_models, Lacto_topics_gamma, Lacto_topics_beta)

topic_SE <- 
  make_topic_SE(
    assay_name = str_c("c_topics_16S_", nrow(combined_topics$beta)), 
    lda_model = combined_topics
  )

MAE <- c(MAE, topic_SE)
```
```{r}
plot_topic_betas(MAE, "c_topics_16S_10")+
  theme(axis.text.x = element_text(angle = 60))
```

To have a little more detailed visualization, we can split the results according to cohort (UMD and Stanford) and plot their respective beta plot:

```{r}
#Separating Stanford from UMD
stan <- MAE[,colnames(MAE) %in% colnames(STAN)]
umd <- MAE[,colnames(MAE) %in% colnames(UMD)]

#Patching up column and rowdata
SE.stan <- stan[["c_topics_16S_10"]]
coldata <- colData(SE.stan)
coldata$SampleID <- rownames(coldata)
coldata <- left_join(coldata |> data.frame(), 
                     colData(STAN[["VM"]]) |> data.frame(), 
                     by = "SampleID")
stan[["c_topics_16S_10"]] <- SummarizedExperiment(assays = assay(SE.stan),
                                                  rowData = rowData(SE.stan),
                                                  colData = coldata)

#Combining topics analysis results with previous MAE object
STAN <- c(STAN, stan)
UMD <- c(UMD, umd)
```
```{r, out.width='50%'}
plot_topic_betas(mae = STAN, assayname = "c_topics_16S_10")+
  theme(axis.text.x = element_text(angle = 60))
plot_topic_betas(mae = UMD, assayname = "c_topics_16S_10")+
  theme(axis.text.x = element_text(angle = 60))
```

```{r}
rm(aligned_topics_product, aligned_topics_transport, beta_long, counts.stan, counts.umd, labelled_lda_models, Lacto_topics_beta, Lacto_topics_gamma, lda_models, non_Lacto_counts, props, props_long, sam_data, props_long_lacto, SE, t.props, tax_table, temp, topics, all_Lacto_species, max_K, optimal_K, other_Lacto_species)
```

## Compositional barplot with agglomerated data

```{r}
## STANFORD
physeq_agg |>
  subset_samples(sample_names(physeq_agg) %in% colnames(STAN[["c_topics_16S_10"]])) |>
  microViz::comp_barplot(tax_level = "ASV_usename", n_taxa = 10, sample_order = "bray", bar_outline_colour = "white", bar_outline_width = 0)+
  labs(subtitle = "Stanford")
## UMD
physeq_agg |>
  subset_samples(sample_names(physeq_agg) %in% colnames(UMD[["c_topics_16S_10"]])) |>
  microViz::comp_barplot(tax_level = "ASV_usename", n_taxa = 10, sample_order = "bray", bar_outline_colour = "white", bar_outline_width = 0)+
  labs(subtitle = "UMD")
```

microViz barplots [source](@misc{microVizBarplot, author={David Barnett}, title = {Plot (grouped and ordered) compositional barplots}, url = {https://david-barnett.github.io/microViz/reference/index.html}})

```{r}
#############STANFORD 
temp <- STAN[["c_topics_16S_10"]] |>
  assay() |>
  data.frame(Topic = rownames(assay(STAN[["c_topics_16S_10"]])),
             check.names = F) |>
  pivot_longer(cols = 1:193, names_to = "Sample", values_to = "prop")

left_join(temp, temp |>
    filter(Topic == "III") |>
    arrange(prop) |>
    mutate(Order = 1:193) |>
    dplyr::select(Sample, Order), by = "Sample") |>
  ggplot()+
  aes(y = prop, x = reorder(Sample,-Order), fill = Topic)+
  #aes(x = Sample, y = prop, fill = Topic)+
  geom_bar(stat = "identity", width = 1)+
  scale_y_continuous(labels = scales::label_percent())+
  labs(y = "Topic proportion", x = "Sample",
       title = "Stanford")+
  theme(axis.text.x = element_blank())

############ UMD

tempU <- UMD[["c_topics_16S_10"]] |>
  assay() |>
  data.frame(Topic = rownames(assay(UMD[["c_topics_16S_10"]])),
             check.names = F) |>
  pivot_longer(cols = 1:200, names_to = "Sample", values_to = "prop")

left_join(tempU, tempU |>
    filter(Topic == "III") |>
    arrange(prop) |>
    mutate(Order = 1:200) |>
    dplyr::select(Sample, Order), by = "Sample") |>
  ggplot()+
  aes(y = prop, x = reorder(Sample,-Order), fill = Topic)+
  #aes(x = Sample, y = prop, fill = Topic)+
  geom_bar(stat = "identity", width = 1)+
  scale_y_continuous(labels = scales::label_percent())+
  labs(y = "Topic proportion", x = "Sample",
       title = "UMD")+
  theme(axis.text.x = element_blank())
```


## Saving results

```{r}
#Saving results
saveRDS(STAN, file = "../05_Results/VM_STANFORD_mae.Rds")
saveRDS(UMD, file = "../05_Results/VM_UMD_mae.Rds")
```
